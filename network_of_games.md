# 游戏网络相关信息

> 对手游来说，省流量就是省钱。

## 差量传输

常见流程为：

|              |                 |                      |            |                            |
| :----------- | :-------------- | :------------------- | :--------- | :------------------------- |
| client       | --->            | server               | --->       | client                     |
| 执行某种行为 | *通过 RPC 请求* | 为该行为进行赋值操作 | *同步数据* | 客户端数据与服务端保持一致 |

该流程的好处在于，服务端的数据同步到客户端，可以避免一些客户端的作弊行为。

从直觉上出发，**同步数据** 这一操作，只发送修改的内容是最节省的方式。

---

## 压缩

在数据发送前，对数据进行压缩是减小流量最有效的方法。

压缩算法选择的几个重点：

- 压缩率越高越好。
- 必须支持流式压缩。（如果所有的数据包都要等待一个完整的大包收到后，再进行解压，会明显增加网络延时）
- CPU 消耗越低越好。
- 内存消耗越少越好。

常见的支持流模式的压缩算法实测比较：

|          |                     |                |                    |
| :------- | :------------------ | :------------- | :----------------- |
|          | zlib                | snappy         | zstd               |
| 压缩率   | 最高                | 较高           | 与 snappy 不相上下 |
| 内存消耗 | 64 KB（参数配置后） | 大于 1 MB      | 大于 1 MB          |
| CPU 消耗 | 一般                | 相对 zlib 较低 | 与 snappy 不相上下 |

## 网络协议

> TCP 在稳定的网络环境下，性能确实优秀。但是在弱网络（如 3G、4G）环境，丢包、延时都存在的情况下，非常容易雪崩，并且难以从系统协议栈层面进行解决。
>  
> UDP 则是只有吞吐量取决于网络环境。但 UDP 的低延时，是在增加重传数据报文的条件下完成的，所以会多付出等同于丢包率比重的额外流量。

因此，我们会将 Gate（网关）、Game（游戏逻辑业务）、DbMgr（数据库操作）、GameMgr（进程管理）这些进程作为内部连接，使用免加密的 TCP 进行通信，提高性能。
而 Client（客户端）、Gate（网关）作为外部连接，使用 UDP 进行实现。

常见的开源 UDP 方案：

|      |                                                                                                                      |                                |
| :--- | :------------------------------------------------------------------------------------------------------------------- | :----------------------------- |
|      | ENET                                                                                                                 | KCP                            |
| 优点 | 实现了较为完整的全套解决方案，很多项目都在用                                                                         | 比较底层，没有太多构建约束     |
| 缺点 | 所有的 client 链接通过一个 socket 来处理，然后在应用层通过一个 channel 编号来区分数据哪一条连接，无法实现 I/O 的并发 | 过于简单，很多功能需要自己实现 |

## 序列化

使用广泛的序列化库有：

|      |          |                                                             |
| :--- | :------: | :---------------------------------------------------------- |
|      | ProtoBuf | FlatBuffer                                                  |
| 优点 |    -     | 序列化计算较快                                              |
| 缺点 |    -     | 一个完整的对象数据，序列化后的大小为 ProtoBuf 的 3.5 倍左右 |

## 存盘

玩家的数据必然是需要持久化处理的，也就是要从内存写到数据盘中。方式有多种，比如 OpLog 和数据库。

1. OpLog（操作日志）

    可以将玩家的行为所产生的数值变化，记录到操作日志中，系统奔溃后，也可以通过日志来进行某一时间段的数据回溯。

2. 数据库

    MongoDB 这类文档型数据库能更加方便地存储类似**树形结构**的玩家数据。

    出于游戏内数据更新非常频繁，并不是很适合在发生写操作的时候，立即生成一个 update 指令来更新数据库。

    建议方案为，创建一组队列，将所有的写操作放置于该队列中，然后启动一组线程，从队列中取出指令，尽可能地合并，再写入数据库中。

## 跨服通信

跨服通信本质上也是服务器进程之间的 RPC 通信，解决方案有诸多参考。
